<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS数组的那些事儿]]></title>
      <url>%2FJS%E6%95%B0%E7%BB%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
      <content type="text"><![CDATA[今儿就把标题列在这！逼自己总结！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[致敬多说，投奔LiveRe]]></title>
      <url>%2F%E8%87%B4%E6%95%AC%E5%A4%9A%E8%AF%B4%EF%BC%8C%E6%8A%95%E5%A5%94LiveRe%2F</url>
      <content type="text"><![CDATA[良心多说 因公司业务调整,非常遗憾的向大家宣布多说项目即将关闭。我们将于2017年6月1日正式关停服务,在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。From 多说官方 国内评论系统，很长一段时间，多说占了大部分市场份额，但无奈被迫关闭，让很多个人站长及部分网站感到失望，更多的，也许是惋惜。多说免费，轻量，好用，虽然经常不稳定但绝对算足够良心。也许是没有找到变现的方式，也许是真的像官方说的，公司业务调整，也许真的有一天，多说会换个姿态回来，不得而知。 只是现在，问题来了，多说的替代方案？ 替代方案 大致折腾了一段时间，整理了下国内及国外主要的第三方评论系统 国内 多说（over） 友言（好像不在维护了） 畅言（需要备案） 网易云跟帖（登录方式有些局限） 国外 DISQUS（评论要翻墙，No） Facebook Comments（不解释） HyperComments（不解释） LiveRe（来必力，韩国友人出的，界面小清新，可能有时候会有点卡，但够用了） 投奔LiveRe(来必力) 今天刚好有空，折腾下博客的评论系统，多说不能用了，虽然文章评论也不多，但之前那篇文章积累了好多评论，现在都没了，有点可惜。 我用的Next主题，这个评论系统已经有人提了PR，官方也支持了（我知道你懒），所以如果你是最新的主题版本，可以直接在主题配置文件里修改：1livere_uid: #your livere_uid 还有几点要说的是， LiveRe网站好像不太稳定，经常无法登陆，不过不需要翻墙，多试几次就好了。 评论是添加的图片不能正常显示 无法导入评论数据（我没找到入口） 评论界面风格是可以选择的，在后台配置可以看到 评论数据分析做得不错，可以重点把玩下 就简单地写这么多吧，最后，致敬多说！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RevealJs(slides演示工具)中文文档]]></title>
      <url>%2FRevealJs-slides%E6%BC%94%E7%A4%BA%E5%B7%A5%E5%85%B7-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[reveal.js 就是在各个互联网大会或者科技发布会常用的幻灯片演示工具，也就是slides，功能强大，自适应移动端和PC端。It translated by Palmer in 2017/5/13. 示例： 左图为移动端，右图为PC端。完整示例：Demo 预览 Demo 预览 工程位于gh-pages分支 工程运行指南 中文文档 官方英文文档 官方文档中文翻译，内容做适当删减 一个使用 HTML 轻松创建精美的演示文稿框架，你只要有一个支持 CSS 3D 切换的浏览器(拥抱Chrome, 拒绝IE)。点击查看 Demo reveal.js 配备了广泛的功能，包括嵌套幻灯片，Markdown 内容，PDF 导出，演讲笔记和 JavaScript API。还有一个全功能的可视化编辑器和平台,可生成在线的slide地址,有免费版和收费版：slides.com。 更多功能 更新日志: 获取最新版本. 例子: 这里有一些基于reveal.js的演示例子,也欢迎PR,提供属于你自己的个性例子! 浏览器支持: 浏览器兼容情况. 插件: 扩展reveal.js功能的插件列表. 在线编辑演示文档是使用 HTML 或者 Markdown 编写的，如果你们更喜欢图形界面的在线编辑器，点击 https://slides.com 尝试一下。 说明结构这里有一个简单的例子,充分展示了reveal.js的演示文档结构.123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="css/reveal.css"&gt; &lt;link rel="stylesheet" href="css/theme/white.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="reveal"&gt; &lt;div class="slides"&gt; &lt;section&gt;Slide 1&lt;/section&gt; &lt;section&gt;Slide 2&lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/reveal.js"&gt;&lt;/script&gt; &lt;script&gt; Reveal.initialize(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 演示文档的标签结构需要 .reveal &gt; .slides &gt; section 包含，一个 section 表示一个 slide 而且可以无限重复。如果你在一个 section 标签里包含了多个 section，那么这几个 section 就会垂直分布（意思就是你需要上下切换 slide），第一个垂直的 slide 位于其它 slide 的顶部，同时也是包含在水平 slide 序列中。举个例子:123456789&lt;div class="reveal"&gt; &lt;div class="slides"&gt; &lt;section&gt;Single Horizontal Slide&lt;/section&gt; &lt;section&gt; &lt;section&gt;Vertical Slide 1&lt;/section&gt; &lt;section&gt;Vertical Slide 2&lt;/section&gt; &lt;/section&gt; &lt;/div&gt;&lt;/div&gt; _Markdownreveal.js 支持 Markdown 来实现内容。使用 Markdown 实现内容时，需要在 section 标签中添加 data-markdown 属性，然后将 Markdown 内容写到一个 text/template 脚本中，如下例。 这是基于 Paul Irish 为了支持 GitHub Flavored Markdown 而修改的 data-markdown，所以对缩进和换行符都是敏感的，应该避免tabs和空格混用，也要注意换行的使用。 1234567&lt;section data-markdown&gt; &lt;script type="text/template"&gt; ## Page title A paragraph with some text and a [link](http://hakim.se). &lt;/script&gt;&lt;/section&gt; 外部 Markdown 文件可以把 Markdown 内容写在外部文件里，在 reveal.js 运行时进行加载。 引用外部文件时可设置的参数： data-separator 定义划分横向幻灯片的规则（默认值为 ^\r?\n---\r?\n$) data-separator-vertical 定义划分纵向幻灯片的规则（默认禁用） data-separator-notes 定义当前幻灯片的演讲备注 (默认值为 note:) data-charset 定义外部文件加载时使用的字符集 如果要在本地使用该特性，演示文稿需要运行在本地服务器上 123456&lt;section data-markdown="example.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:" data-charset="iso-8859-15"&gt;&lt;/section&gt; 元素属性在 Markdown 内容中，可以通过 html 注释来添加元素属性，如分段： 123456&lt;section data-markdown&gt; &lt;script type="text/template"&gt; - 列表项 1 &lt;!-- .element: class="fragment" data-fragment-index="2" --&gt; - 列表项 2 &lt;!-- .element: class="fragment" data-fragment-index="1" --&gt; &lt;/script&gt;&lt;/section&gt; 幻灯片属性html 注释也可以用来添加幻灯片 &lt;section&gt; 元素的属性。 123456&lt;section data-markdown&gt; &lt;script type="text/template"&gt; &lt;!-- .slide: data-background="#ff0000" --&gt; Markdown 内容 &lt;/script&gt;&lt;/section&gt; 配置 markedreveal.js 使用 marked 来解析 Markdown，可在设置reveal 配置 时传入 marked 的配置： 1234567Reveal.initialize(&#123; // 传入 marked 的配置 // 参考 https://github.com/chjj/marked#options-1 markdown: &#123; smartypants: true &#125;&#125;); 配置需在页面底部初始化 reveal，所有配置项均为可选，默认值如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Reveal.initialize(&#123; // 在右下角显示控制面板 controls: true, // 显示演示进度条 progress: true, // 显示幻灯片页码 // 可使用代码 slideNumber: 'c/t'，表示 '当前页/总页数' slideNumber: false, // 幻灯片切换时写入浏览器历史记录 history: false, // 启用键盘快捷键 keyboard: true, // 启用幻灯片概览 overview: true, // 幻灯片垂直居中 center: true, // 在触屏设备上启用触摸滑动切换 touch: true, // 循环演示 loop: false, // 演示方向为右往左，即向左切换为下一张，向右切换为上一张 rtl: false, // 打乱幻灯片顺序 shuffle: false, // 启用幻灯片分段 fragments: true, // 演示文稿是否运行于嵌入模式（如只占页面的一部分） // 译者注：与触屏相关 // false：所有在演示文稿上触发的 "touchmove" 的默认行为都会被阻止 // true：只有在 "touchmove" 触发了演示文稿事件时才会阻止默认行为 embedded: false, // 是否在按下 ? 键时显示快捷键帮助面板 help: true, // 演讲备注是否对所有人可见 showNotes: false, // 两个幻灯片之间自动播放的时间间隔（毫秒），当设置为 0 时，则禁止自动播放。 // 该值可以被幻灯片上的 `data-autoslide` 属性覆盖 autoSlide: 0, // 允许停止自动播放 // 在手动切换分段或幻灯片后暂停自动播放 // 按 a 键暂停或恢复自动播放 autoSlideStoppable: true, // 使用该函数执行自动播放操作 autoSlideMethod: Reveal.navigateNext, // 启用鼠标滚轮切换幻灯片，作用与 SPACE 相同 mouseWheel: false, // 在移动设备上隐藏地址栏 hideAddressBar: true, // 在 iframe 预览弹框中打开链接 previewLinks: false, // 切换过渡效果 // none-无/fade-渐变/slide-飞入/convex-凸面/concave-凹面/zoom-缩放 transition: 'slide', // none/fade/slide/convex/concave/zoom // 切换过渡速度 // default-中速/fast-快速/slow-慢速 transitionSpeed: 'default', // default/fast/slow // 背景切换过渡效果 backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom // 预加载幻灯片数 viewDistance: 3, // 视差背景图 parallaxBackgroundImage: '', // 示例："'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'" // 视察背景图尺寸 parallaxBackgroundSize: '', // CSS 写法，示例："2100px 900px"（目前只支持像素值，不支持 % 和 auto） // 相邻两张幻灯片间，视差背景移动的像素值 // - 如果不设置则自动计算 // - 当设置为 0 时，则禁止视差动画 parallaxBackgroundHorizontal: null, parallaxBackgroundVertical: null&#125;); 在执行初始化后，可通过 configure 方法来更新配置： 12345// 关闭自动播放Reveal.configure(&#123; autoSlide: 0 &#125;);// 开启自动播放（时间间隔为 5 秒）Reveal.configure(&#123; autoSlide: 5000 &#125;); 演示文稿尺寸演示文稿有一个标准尺寸，框架会在其基础上自动缩放以适应各种分辨率。 尺寸相关的配置项及其默认值如下：1234567891011121314151617Reveal.initialize(&#123; ... // 演示文稿缩放时，会保持标准尺寸的宽高比。 // 可使用百分比，如：'200%' width: 960, height: 700, // 内容外边距 margin: 0.1, // 内容缩放比例的最小值/最大值 minScale: 0.2, maxScale: 1.5&#125;); 如果想要使用自定义的缩放方式（如使用媒体查询），可通过下面的设置来禁用自动缩放：12345678910Reveal.initialize(&#123; ... width: "100%", height: "100%", margin: 0, minScale: 1, maxScale: 1&#125;); 依赖Reveal.js 的部分功能需要引入自带的第三方库，可在初始化时传入依赖项，运行时会自动加载。 12345678910111213141516171819202122Reveal.initialize(&#123; dependencies: [ // classList 跨浏览器支持 - https://github.com/eligrey/classList.js/ &#123; src: 'lib/js/classList.js', condition: function() &#123; return !document.body.classList; &#125; &#125;, // 解析 &lt;section&gt; 元素里的 Markdown 内容 &#123; src: 'plugin/markdown/marked.js', condition: function() &#123; return !!document.querySelector( '[data-markdown]' ); &#125; &#125;, &#123; src: 'plugin/markdown/markdown.js', condition: function() &#123; return !!document.querySelector( '[data-markdown]' ); &#125; &#125;, // &lt;code&gt; 元素语法高亮 &#123; src: 'plugin/highlight/highlight.js', async: true, callback: function() &#123; hljs.initHighlightingOnLoad(); &#125; &#125;, // Alt+click 缩放点击元素 &#123; src: 'plugin/zoom-js/zoom.js', async: true &#125;, // 演讲备注 &#123; src: 'plugin/notes/notes.js', async: true &#125;, // 数学公式 &#123; src: 'plugin/math/math.js', async: true &#125; ]&#125;); 自定义库也可以使用该方式加载。依赖项属性： src: 脚本路径 async: [可选] 异步，是否允许 reveal.js 执行后再加载脚本，默认值为 false callback: [可选] 回调函数，脚本加载完成后执行 condition: [可选] 条件函数，返回 true 时才会加载脚本 要使用该方式来加载依赖项，需在引入 reveal.js 之前引入 head.js (提供加载脚本功能的库)。 Ready事件reveal.js 在所有非异步依赖加载完成，准备播放时，会广播 ‘ready’ 事件。可调用 Reveal.isReady() 函数来检查 reveal.js 是否已准备完成。 123Reveal.addEventListener( 'ready', function( event ) &#123; // event.currentSlide, event.indexh, event.indexv&#125; ); reveal.js 准备完成时会给 .reveal 元素增加 .ready 类，也可以此来判断是否已准备完成。 自动播放演示文稿可以设置为自动播放，只需告诉框架自动切换的时间间隔（毫秒）： 1234// 每 5 秒自动切换下一张幻灯片Reveal.configure(&#123; autoSlide: 5000&#125;); 在手动切换分段或幻灯片后会暂停自动播放，也可以按 a 键来暂停或恢复自动播放。设置 false``` 后，用户操作则不会打断自动播放。123456789也可以通过 ```data-autoslide``` 属性来给个别幻灯片或分段重新设置时间间隔:```html&lt;section data-autoslide=&quot;2000&quot;&gt; &lt;p class=&quot;fragment&quot;&gt; 2 秒后第一个分段会自动显示 &lt;/p&gt; &lt;p class=&quot;fragment&quot; data-autoslide=&quot;10000&quot;&gt; 10 秒后下一个分段会自动显示 &lt;/p&gt; &lt;p class=&quot;fragment&quot;&gt; 2 秒后会自动切换到下一张幻灯片 &lt;/p&gt;&lt;/section&gt; 通过设置 指定自动播放的方式，如设置为 ```Reveal.navigateRight```，则自动播放时纵向幻灯片只会播放主幻灯片，其它纵向幻灯片会被忽略。123456789101112131415自动播放被暂停和恢复时，会广播 ```autoslidepaused``` 和 ```autoslideresumed``` 事件。## 自定义快捷键如果不喜欢默认的快捷键，可通过 ```keyboard``` 配置项来自定义：```javascriptReveal.configure(&#123; keyboard: &#123; 13: &apos;next&apos;, // 按 ENTER 键切换到下一个分段或幻灯片 27: function() &#123;&#125;, // 按 ESC 键时触发自定义行为 32: null // 按 SPACE 时不做任何处理（可用于禁用 reveal.js 的默认快捷键） &#125;&#125;); 触屏操作在触屏设备上可以通过滑动来操作幻灯片，水平滑动切换横向幻灯片，垂直滑动切换纵向幻灯片。设置 false`` 可禁用触屏操作。123456789101112131415161718192021如果幻灯片内容本身带有滑动操作（比如滚动内容），需要给元素添加 `data-prevent-swipe` 属性来阻止默认的滑动行为。## 延迟加载当演示文稿中带有大量的多媒体或 iframe 内容时，延迟加载就显得尤为重要，即只提前加载当前幻灯片最近的几张幻灯片中的内容。预加载的幻灯片数量由 `viewDistance` 配置项决定。延迟加载支持 image、video、audio 和 iframe 元素，只需把 &quot;src&quot; 属性改为 &quot;data-src&quot; 即可。幻灯片中延迟加载的 iframe，会在切换到其它幻灯片时自动卸载。```html&lt;section&gt; &lt;img data-src=&quot;图片.png&quot;&gt; &lt;iframe data-src=&quot;http://hakim.se&quot;&gt;&lt;/iframe&gt; &lt;video&gt; &lt;source data-src=&quot;视频.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;source data-src=&quot;视频.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt;&lt;/section&gt; API中文Reveal 对象提供了一套控制演示进度和管理演示状态的 JavaScript API： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 演示进度控制Reveal.slide( indexh, indexv, indexf );Reveal.left();Reveal.right();Reveal.up();Reveal.down();Reveal.prev();Reveal.next();Reveal.prevFragment();Reveal.nextFragment();// 打乱幻灯片顺序Reveal.shuffle();// 显示快捷键帮助面板Reveal.showHelp();// 管理演示文稿状态，传入 true/false 对应 on/off 状态Reveal.toggleOverview();Reveal.togglePause();Reveal.toggleAutoSlide();// 改变配置项设置Reveal.configure(&#123; controls: true &#125;);// 获取当前的配置项设置Reveal.getConfig();// 获取当前演示文稿的缩放比例Reveal.getScale();// 获取上一个/当前幻灯片节点Reveal.getPreviousSlide();Reveal.getCurrentSlide();// 获取当前演示状态// h-横向幻灯片索引，v-纵向幻灯片索引，f-分段索引Reveal.getIndices(); // &#123; h: 0, v: 0, f: 0 &#125;// 获取当前演示进度Reveal.getProgress(); // 0-1// 获取幻灯片总数（包括横向幻灯片和纵向幻灯片）Reveal.getTotalSlides();// 获取当前幻灯片的演讲备注Reveal.getSlideNotes();// 状态检查Reveal.isFirstSlide();Reveal.isLastSlide();Reveal.isOverview();Reveal.isPaused();Reveal.isAutoSliding(); 幻灯片切换事件幻灯片切换时会广播 ‘slidechanged’ 事件。event 对象保存了当前幻灯片的横向索引和纵向索引、上一张幻灯片和当前幻灯片的节点引用。 部分第三方库，如 MathJax（见 #226），会受到幻灯片变形和显示状态的影响，此时可以尝试在该事件的回调函数中重新计算和渲染来进行修复。 123Reveal.addEventListener( 'slidechanged', function( event ) &#123; // event.previousSlide, event.currentSlide, event.indexh, event.indexv&#125; ); 演示状态getState 方法可以获取演示文稿的当前状态，使用这个快照，可以非常方便地返回到记录的演示进度。 1234567891011// 切换到幻灯片 1Reveal.slide( 1 );// 获取当前状态var state = Reveal.getState();// 切换到幻灯片 3Reveal.slide( 3 );// 切回幻灯片 1Reveal.setState( state ); 幻灯片状态如果给幻灯片 &lt;section&gt; 设置了 data-state=&quot;somestate&quot; 属性，则当播放到该幻灯片时，”somestate” 将会出现在文档元素 &lt;html&gt; 的类里，可以很方便地给各个幻灯片设置不同的页面样式。 此外，还可以在 JavaScript 中侦听这个状态： 123Reveal.addEventListener( 'somestate', function() &#123; // TODO: somestate 出现了，做些啥吧&#125;, false ); 幻灯片背景元素的 ```data-background``` 属性可以设置一个覆盖整个幻灯片的背景。12345678支持 4 种类型的背景：颜色，图像，视频和 iframe。#### 颜色背景支持所有 CSS 颜色格式，如 rgba() 或 hsl()。```html&lt;section data-background-color=&quot;#ff0000&quot;&gt; &lt;h2&gt; 颜色背景 &lt;/h2&gt;&lt;/section&gt; 图像背景背景图像默认会自动调整大小以覆盖整个幻灯片，可设置的选项： 属性 默认值 说明 data-background-image 图片 URL（GIF 动图会在幻灯片显示时重新播放） data-background-size cover 见 MDN background-size data-background-position center 见 MDN background-position data-background-repeat no-repeat 见 MDN background-repeat 123456&lt;section data-background-image="http://example.com/image.png"&gt; &lt;h2&gt; 图像背景 &lt;/h2&gt;&lt;/section&gt;&lt;section data-background-image="http://example.com/image.png" data-background-size="100px" data-background-repeat="repeat"&gt; &lt;h2&gt; 背景图像尺寸为 100 像素，且平铺模式为重复 &lt;/h2&gt;&lt;/section&gt; 视频背景在幻灯片后面自动播放一个撑满页面的视频。 属性 默认值 说明 data-background-video 单个视频地址，或由半角逗号 ‘,’ 分隔的视频地址列表。 data-background-video-loop false 是否循环播放 data-background-video-muted false 是否静音 123&lt;section data-background-video="https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.mp4,https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.webm" data-background-video-loop data-background-video-muted&gt; &lt;h2&gt; 视频背景 &lt;/h2&gt;&lt;/section&gt; Iframe 背景嵌入一个网页作为背景，该网页位于幻灯片后面的背景层，无法进行交互。123&lt;section data-background-iframe="https://slides.com"&gt; &lt;h2&gt; Iframe &lt;/h2&gt;&lt;/section&gt; 背景切换过渡效果背景切换的默认过渡效果为 fade（渐变），可在初始化 时传入 ```backgroundTransition``` 配置项来修改，也可给 `` 添加 ```data-background-transition``` 属性来给个别幻灯片单独设置。123456789101112131415161718192021#### 视差背景要使用视差滚动背景，需要在初始化 reveal.js 时设置下面的前两个配置项（后两个为可选项）。```javascriptReveal.initialize(&#123; // 视差背景图 parallaxBackgroundImage: &apos;&apos;, // 示例：&quot;&apos;https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg&apos;&quot; // 视察背景图尺寸 parallaxBackgroundSize: &apos;&apos;, // CSS 写法，示例：&quot;2100px 900px&quot;（目前只支持像素值，不支持 % 和 auto） // 相邻两张幻灯片间，视差背景移动的像素值 // - 如果不设置则自动计算 // - 当设置为 0 时，则禁止视差动画 parallaxBackgroundHorizontal: 200, parallaxBackgroundVertical: 50&#125;); 视差背景图尺寸必须大于幻灯片尺寸，否则切换幻灯片时无法滚动。查看示例 切换过渡效果幻灯片的切换过渡效果，默认使用配置项 设置的值，可通过 ```data-transition``` 属性来给个别幻灯片单独指定过渡效果：123456789```html&lt;section data-transition=&quot;zoom&quot;&gt; &lt;h2&gt; 该幻灯片不使用全局的切换过渡效果，而是单独指定的缩放！ &lt;/h2&gt;&lt;/section&gt;&lt;section data-transition-speed=&quot;fast&quot;&gt; &lt;h2&gt; 可供选择的切换过渡速度有：default-中速、fast-快速、slow-慢速！ &lt;/h2&gt;&lt;/section&gt; 甚至可以给同一张幻灯片指定不同的切入和切出过渡效果： 123456789101112131415&lt;section data-transition="slide"&gt; 没时间解释了快上车……&lt;/section&gt;&lt;section data-transition="slide"&gt; 继续前进……&lt;/section&gt;&lt;section data-transition="slide-in fade-out"&gt; 到站停车。&lt;/section&gt;&lt;section data-transition="fade-in slide-out"&gt; （乘客上车和下车）&lt;/section&gt;&lt;section data-transition="slide"&gt; 重新上路。&lt;/section&gt; 内部跳转幻灯片间的跳转十分简单，下面第一个例子指定的是目标幻灯片的索引，第二个例子指定的是目标幻灯片的 ID 属性（id="some-slide">```）：1234```html&lt;a href=&quot;#/2/1&quot;&gt; 跳转到第 3 个横向幻灯片的第 2 个纵向幻灯片 &lt;/a&gt;&lt;a href=&quot;#/some-slide&quot;&gt; 跳转到 ID 为 some-slide 的幻灯片 &lt;/a&gt; 也可以给元素添加下面这些类，来指定一个相对地址，类似于 reveal.js 的控制面板。如果指定的是一个有效的跳转地址，元素会自动附加 类。12345678```html&lt;a href=&quot;#&quot; class=&quot;navigate-left&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;navigate-right&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;navigate-up&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;navigate-down&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;navigate-prev&quot;&gt; &lt;!-- 上一张纵向幻灯片或横向幻灯片 --&gt;&lt;a href=&quot;#&quot; class=&quot;navigate-next&quot;&gt; &lt;!-- 下一张纵向幻灯片或横向幻灯片 --&gt; 片段分段可用于强调幻灯片中的个别元素。演示文稿向前播放时，所有带有 类的元素，会在切换下个幻灯片之前逐个触发。[查看示例](http://lab.hakim.se/reveal-js/#/fragments)123456789101112131415分段默认是初始隐藏，播放时渐显出现，可通过给分段追加类来修改这个效果：```html&lt;section&gt; &lt;p class=&quot;fragment grow&quot;&gt; 放大：初始可见，播放时放大 &lt;/p&gt; &lt;p class=&quot;fragment shrink&quot;&gt; 缩小：初始可见，播放时缩小 &lt;/p&gt; &lt;p class=&quot;fragment fade-out&quot;&gt; 渐隐消失：初始可见，播放时渐隐消失 &lt;/p&gt; &lt;p class=&quot;fragment fade-up&quot;&gt; 渐显上升：初始隐藏，播放时渐显上升出现（down、left、right 类似） &lt;/p&gt; &lt;p class=&quot;fragment current-visible&quot;&gt; 显示一次：初始隐藏，播放时出现，继续播放则消失 &lt;/p&gt; &lt;p class=&quot;fragment highlight-current-blue&quot;&gt; 高亮蓝一次：初始可见，播放时变蓝，继续播放则恢复颜色 &lt;/p&gt; &lt;p class=&quot;fragment highlight-red&quot;&gt; 高亮红：初始可见，播放时变红 &lt;/p&gt; &lt;p class=&quot;fragment highlight-green&quot;&gt; 高亮绿：初始可见，播放时变绿 &lt;/p&gt; &lt;p class=&quot;fragment highlight-blue&quot;&gt; 高亮蓝：初始可见，播放时变蓝 &lt;/p&gt;&lt;/section&gt; 嵌套分段会对包裹的内容逐个触发，在下面的例子中，播放时文本会先渐显出现，继续播放则文本渐隐消失。 12345&lt;section&gt; &lt;span class="fragment fade-in"&gt; &lt;span class="fragment fade-out"&gt; 我将渐显出现，然后渐隐消失 &lt;/span&gt; &lt;/span&gt;&lt;/section&gt; 分段的播放顺序，可以通过 属性来控制。1234567```html&lt;section&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;3&quot;&gt; 最后播放 &lt;/p&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;1&quot;&gt; 最先播放 &lt;/p&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;2&quot;&gt; 第二个播放 &lt;/p&gt;&lt;/section&gt; 片段事件任意分段在出现和隐藏时，reveal.js 都会广播事件。 部分第三方库，如 MathJax（见 #505），会受到初始隐藏的分段元素的影响，此时可以尝试在这些事件的回调函数中重新计算和渲染来进行修复。 123456Reveal.addEventListener( 'fragmentshown', function( event ) &#123; // event.fragment = 分段元素节点&#125; );Reveal.addEventListener( 'fragmenthidden', function( event ) &#123; // event.fragment = 分段元素节点&#125; ); 代码语法高亮Reveal 自带代码语法高亮插件 highlight.js（需引入该依赖项）。在下面的例子中， clojure 代码会自动语法高亮，指定 data-trim 属性可以自动删除多余空格。HTML 默认会自动转义，要避免转义（如例子中的 &lt;mark&gt; 标签要显示出来），可以给 &lt;code&gt; 元素追加 data-noescape 属性。 123456789&lt;section&gt; &lt;pre&gt;&lt;code data-trim data-noescape&gt;(def lazy-fib (concat [0 1] &lt;mark&gt;((fn rfib [a b]&lt;/mark&gt; (lazy-cons (+ a b) (rfib b (+ a b)))) 0 1))) &lt;/code&gt;&lt;/pre&gt;&lt;/section&gt; 幻灯片页码如果想显示幻灯片页码，可以设置 配置项。1234567891011```javascript// 使用默认格式显示幻灯片页码Reveal.configure(&#123; slideNumber: true &#125;);// 可供选择的幻灯片页码格式：// &quot;h.v&quot;: 当前横向幻灯片页码 . 当前纵向幻灯片页码 (默认)// &quot;h/v&quot;: 当前横向幻灯片页码 / 当前纵向幻灯片页码// &quot;c&quot;: 当前幻灯片页码（包括横向幻灯片和纵向幻灯片）// &quot;c/t&quot;: 当前幻灯片页码 / 幻灯片总数Reveal.configure(&#123; slideNumber: &apos;c/t&apos; &#125;); 概览模式按 “Esc” 或 “o” 键可以打开或关闭概览模式。在概览模式中，你仍然可以在幻灯片间切换，就好像位于演示文稿的上空，操作平铺开来的幻灯片。与概览模式相关的 API： 12345Reveal.addEventListener( 'overviewshown', function( event ) &#123; /* ... */ &#125; );Reveal.addEventListener( 'overviewhidden', function( event ) &#123; /* ... */ &#125; );// 通过代码打开或关闭概览模式Reveal.toggleOverview(); 全屏模式按 »F« 键可以让演示文稿进入全屏模式，按 »ESC« 键退出全屏模式。 嵌入媒体嵌入的 HTML5 &lt;video&gt;/&lt;audio&gt; 和 YouTube iframe，会在幻灯片切出时自动暂停播放，通过给元素添加 data-ignore 属性可以禁止该行为。 给媒体元素添加 data-autoplay 属性，则在幻灯片显示时媒体将自动播放： 1&lt;video data-autoplay src="http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"&gt;&lt;/video&gt; 此外，框架会自动发送两条消息（见 发送消息）给所有的 iframe。包含 iframe 的幻灯片，显示时会给其内部所有的 iframe 发送 ```slide:stop``` 消息。1234567891011### 拉伸元素有时我们希望元素（如图像或者视频）可以自动拉伸，尽可能多的占用幻灯片的空间，这时可以给元素添加 ```.stretch``` 类：```html&lt;section&gt; &lt;h2&gt; 这个视频将占用幻灯片的所有剩余空间 &lt;/h2&gt; &lt;video class=&quot;stretch&quot; src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt;&lt;/section&gt; 限制： 只能用于幻灯片的直接子元素 每个幻灯片最多只能设置 1 个子元素 通信 API框架自带一个发送消息 API 1234下面的例子展示了如何让指定窗口中的 reveal.js 实例切换到幻灯片 2：```javascript&lt;window&gt;.postMessage( JSON.stringify(&#123; method: &apos;slide&apos;, args: [ 2 ] &#125;), &apos;*&apos; ); 译者注示例可参考 icewind1991 的 plugin/postmessage。reveal.js 已自带该特性，无需额外引入 postmessage.js 插件。123456789101112131415161718192021222324252627&lt;html&gt; &lt;body&gt; &lt;iframe id="reveal" src="../../index.html" style="border: 0;" width="500" height="500"&gt;&lt;/iframe&gt; &lt;div&gt; &lt;input id="back" type="button" value="后退"/&gt; &lt;input id="ahead" type="button" value="前进"/&gt; &lt;input id="slideto" type="button" value="切换到 2-2"/&gt; &lt;/div&gt; &lt;script&gt; (function ()&#123; var back = document.getElementById( 'back' ), ahead = document.getElementById( 'ahead' ), slideto = document.getElementById( 'slideto' ), reveal = window.frames[0]; back.addEventListener( 'click', function () &#123; reveal.postMessage( JSON.stringify(&#123;method: 'prev', args: []&#125;), '*' ); &#125;, false ); ahead.addEventListener( 'click', function ()&#123; reveal.postMessage( JSON.stringify(&#123;method: 'next', args: []&#125;), '*' ); &#125;, false ); slideto.addEventListener( 'click', function ()&#123; reveal.postMessage( JSON.stringify(&#123;method: 'slide', args: [2,2]&#125;), '*' ); &#125;, false ); &#125;()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; reveal.js 在 iframe 中运行时，可选择是否将其所有事件冒泡给父窗口。冒泡的事件对象为一个 JSON 字符串，保存了 3 个字段：namespace-命名空间、eventName-事件名、state-状态。下面的例子展示了父窗口如何向 reveal 订阅事件： 123456window.addEventListener( 'message', function( event ) &#123; var data = JSON.parse( event.data ); if( data.namespace === 'reveal' &amp;&amp; data.eventName ==='slidechanged' ) &#123; // 幻灯片切换，可访问 data.state 来查看幻灯片页码 &#125;&#125; ); 跨窗口消息传递可通过配置项来打开或关闭。 123456789Reveal.initialize(&#123; ..., // 暴露 postMessage API postMessage: true, // 将演示文稿的所有事件冒泡给父窗口 postMessageEvents: false&#125;); 导出 PDF演示文稿可以通过一个特殊的打印样式来导出 PDF。该特性需要使用 Google Chrome 或 Chromium、且运行于 web 服务器上时，可以导出为 PDF。这是一个演示文稿导出 PDF 并上传到 SlideShare 的例子：http://www.slideshare.net/hakimel/revealjs-300。 页面尺寸导出的 PDF 尺寸由 演示文稿尺寸 决定，如果幻灯片太高无法一页展示完，则会切分为多页，可通过 pdfMaxPagesPerSlide 配置项设置每张幻灯片最多可被切分为几数，如 Reveal.configure({ pdfMaxPagesPerSlide: 1 }) 可确保幻灯片不会被切分。 打印样式想要启用演示文稿的打印功能，需要加载一个用于打印的特殊样式 /css/print/pdf.css，默认的 index.html 文件已包含该逻辑，只要演示文稿的链接中带有 print-pdf 参数，就会自动加载。如果使用的是其它的 HTML 模板，可以在 HEAD 中插入以下代码： 1234567&lt;script&gt; var link = document.createElement( 'link' ); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css'; document.getElementsByTagName( 'head' )[0].appendChild( link );&lt;/script&gt; 步骤 给演示文稿的 URL 加上 print-pdf 参数，如：http://localhost:8000/?print-pdf#/ ，可以尝试这个例子 lab.hakim.se/reveal-js?print-pdf。 打开浏览器的打印面板 (CTRL/CMD+P)。 Destination（目标打印机） 修改为 Save as PDF（另存为 PDF）。 Layout（布局） 修改为 Landscape（横向）。 Margins（边距） 修改为 None（无）。 启用选项 Background graphics（背景图形）。 点击 Save（保存） 也可使用 decktape（一个将 HTML5 演示文稿导出为高质量 PDF 的框架）项目代替。 主题框架带有几个不同的主题： black：黑色背景，白色文本，蓝色链接（默认主题） white：白色背景，黑色文本，蓝色链接 league：灰色背景，白色文本，蓝色链接（reveal.js 3.0.0 之前版本的默认主题） beige：米黄色背景，暗色（#333）文本，棕色链接 sky：蓝色背景，暗色文本，蓝色链接 night：黑色背景，亮色（#eee）文本，橙色链接 serif：咖啡色背景，灰色文本，褐色链接 simple：白色背景，黑色文本，蓝色链接 solarized：奶油色背景，深绿色文本，蓝色链接 每个主题都是一个单独的样式文件，修改主题只需把 index.html 的主题样式中的 black 替换为想要的主题名即可： 1&lt;link rel="stylesheet" href="css/theme/black.css" id="theme"&gt; 如果要增加自定义主题，请参考：/css/theme/README.md。 演讲备注reveal.js 自带演讲备注插件，可以在一个单独的浏览器窗口中为每张幻灯片提供备注，同时预览下一张幻灯片。按 ‘s’ 键来打开备注窗口。 演讲计时器会在备注窗口打开时启动，点击时间可以重置为 00:00:00。 给幻灯片追加一个 元素来添加备注，如果想用 Markdown 编写备注内容，可以给 aside 元素添加 ```data-markdown``` 属性。12345678910111213也可以通过幻灯片的 `data-notes` 属性来添加简单的备注，如 `&lt;section data-notes=&quot;一些简单的备注&quot;&gt;&lt;/section&gt;`。如果是在本地打开演示文稿，想要使用演讲备注，需要 reveal.js [运行于一个本地 web 服务器](#完整安装).```html&lt;section&gt; &lt;h2&gt; 我是幻灯片 &lt;/h2&gt; &lt;aside class=&quot;notes&quot;&gt; 大家好，我是这张幻灯片的备注，在演示文稿上是看不到，不过可以按 &apos;s&apos; 键打开备注窗口来找我哦，么么哒~ &lt;/aside&gt;&lt;/section&gt; 对于幻灯片引入的外部 Markdown 文件，可以在指定的分隔符后面添加备注： 123456789&lt;section data-markdown="example.md" data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:"&gt;&lt;/section&gt;# 标题## 子标题幻灯片内容……Note:只会在备注窗口显示的内容…… 分享和打印演讲备注备注只对演讲者可见，如果想让其他人也能看到，可以在初始化 reveal.js 时，把 showNotes 配置项设为 true，则备注会显示在演示文稿的底部。 如果启用了 showNotes，在 导出 PDF 时也会包含备注。备注默认打印在一个半透明的浮窗中，覆盖于幻灯片底部，如果想在该幻灯片后面单独新建一页打印备注，可以把 showNotes 设置为 &quot;separate-page&quot;。 服务器端演讲备注基于 Node.js 的演讲备注插件，让你可以在其它设备上运行你正在控制的演讲备注，就像客户端演讲备注的副本，会相互同步操作。需要引入以下依赖项： 12345678Reveal.initialize(&#123; ... dependencies: [ &#123; src: 'socket.io/socket.io.js', async: true &#125;, &#123; src: 'plugin/notes-server/client.js', async: true &#125; ]&#125;); 然后： 安装 Node.js（4.0.0 或更新版本） 执行 install```13. 执行 ```node plugin/notes-server 多路复用多路复用插件让你的听众可以在自己的手机、平板电脑或笔记本电脑上观看你正在控制的演示文稿，当你操作主演示文稿时，所有的客户端演示文稿将实时同步更新。查看示例：https://reveal-js-multiplex-ccjbegmaii.now.sh/。 多路复用插件需要以下 3 个部分： 可以控制的主演示文稿 同步更新的客户端演示文稿 用于广播主演示文稿事件给客户端演示文稿的 Socket.io 服务器 更多说明： 主演示文稿存放于只有演讲者可以访问（最好）的静态文件服务器（存放在演讲者的电脑上即可，在演讲者的电脑上运行主演示文稿会更加保险，即使会场断网，也不会打断演示。）。在主演示文稿目录中执行以下命令： install node-static```12. ```static 如果想在主演示文稿上使用演讲备注，需要先配置演讲备注插件，然后在主演示文稿目录中执行 plugin/notes-server``` 命令。12345678910111213141516171819202122232425262728运行演讲备注/静态文件服务器，作为主控端连接 socket.io 服务器。通过 ```http://localhost:1947``` 访问主演示文稿。配置示例：```javascriptReveal.initialize(&#123; // 其它配置项…… multiplex: &#123; // 示例值，使用时请自己生成，具体参考 socket.io 说明。 secret: &apos;13652805320794272084&apos;, // 从 socket.io 服务器获得，允许演示文稿可以被控制 id: &apos;1ea875674b17ca76&apos;, // 从 socket.io 服务器获得 url: &apos;https://reveal-js-multiplex-ccjbegmaii.now.sh&apos; // socket.io 服务器地址 &#125;, // 依赖项 dependencies: [ &#123; src: &apos;//cdn.socket.io/socket.io-1.3.5.js&apos;, async: true &#125;, &#123; src: &apos;plugin/multiplex/master.js&apos;, async: true &#125;, // 演讲备注 &#123; src: &apos;plugin/notes-server/client.js&apos;, async: true &#125; // 其它依赖项…… ]&#125;); 客户端演示文稿存放于可以公开访问的静态文件服务器，如 GitHub Pages、Amazon S3、Dreamhost、Akamai 等。 使用下面的配置，当听众通过 访问演示文稿时，将作为被控端连接 socket.io 服务器。123456789101112131415161718192021配置示例：```javascriptReveal.initialize(&#123; // 其它配置项…… multiplex: &#123; // 示例值，使用时请自己生成，具体参考 socket.io 说明。 secret: null, // 设置为 null，演示文稿将不能被控制，而是同步 socket.io 服务器上相同 id 的主演示文稿的操作 id: &apos;1ea875674b17ca76&apos;, // 从 socket.io 服务器获得 url: &apos;https://reveal-js-multiplex-ccjbegmaii.now.sh&apos; // socket.io 服务器地址 &#125;, // 依赖项 dependencies: [ &#123; src: &apos;//cdn.socket.io/socket.io-1.3.5.js&apos;, async: true &#125;, &#123; src: &apos;plugin/multiplex/client.js&apos;, async: true &#125; // 其它依赖项…… ]&#125;); _MathJax如果想在演示文稿中更好的显示数学公式，可以使用基于 MathJax 库封装的这个小插件。 插件默认使用 LaTeX 格式（一种基于ΤΕΧ的排版系统），可通过 配置项来修改。12345678910111213141516171819MathJax 是从远程服务器加载的，如果想离线使用，需自行下载该库，并修改 ```mathjax``` 配置项。下面是 MathJax 的配置示例（使用默认配置时，```math``` 配置项可省略）：```jsReveal.initialize(&#123; // 其它配置项…… math: &#123; mathjax: &apos;https://cdn.mathjax.org/mathjax/latest/MathJax.js&apos;, config: &apos;TeX-AMS_HTML-full&apos; // 参考 http://docs.mathjax.org/en/latest/config-files.html &#125;, dependencies: [ &#123; src: &apos;plugin/math/math.js&apos;, async: true &#125; ]&#125;); 如果想了解 MathJax 的 HTTPS 传输方式，或为了稳定性需要使用特定版本，请参考 MathJax 的说明文档。 工程安装基础安装 适用于创建简单的演讲文稿，完整安装 可以使用 reveal.js 的所有特性和插件（如演讲备注）。 基础安装reveal.js 基础功能的安装十分简单，只需下载框架包，然后直接在浏览器中打开 index.html 文件即可。 在 https://github.com/hakimel/reveal.js/releases 上下载 reveal.js 的最新版本 解压缩，然后将 index.html 里的示例内容修改为自己的内容 在浏览器中打开 index.html 完整安装部分 reveal.js 特性（如 Markdown 和演讲备注）需要演示文稿运行于一个本地 web 服务器。按照下面的步骤，可以创建一个完整的 reveal.js 开发和运行环境： 安装 Node.js （4.0.0 或更新版本） 克隆 reveal.js 仓库 1$ git clone https://github.com/palmerye/demos-Reveal.js.git 进入 reveal.js 目录 1$ cd reveal.js 安装依赖 1$ npm install 启动演示文稿并监控文件变更 1$ npm start 打开 http://localhost:8000 查看演示文稿 通过 npm start -- --port=8001 指令可修改端口号 目录结构 css/ 框架样式 js/ 框架 JavaScript plugin/ 用于扩展 reveal.js 的组件 lib/ 第三方库（JavaScript、样式、字体） 许可遵循 MIT 开源协议 Copyright (C) 2016 Hakim El Hattab, http://hakim.se]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何在Windows下像Mac一样优雅开发]]></title>
      <url>%2F%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8B%E5%83%8FMac%E4%B8%80%E6%A0%B7%E4%BC%98%E9%9B%85%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[起因：之前一直用Mac开发，换了家公司，只许用Windows下开发，说实话，一开始我是拒绝的，可自从看到了这几个工具以后…… 下文大标题说明：（Mac下的工具）VS（Windows下的工具），Mac下的工具说明会简要点，毕竟看文章的基本上都是实在受不了Windows的重度Mac开发者。 1. item2 VS Cmder 终端工具 - iterm2iterm2是Mac下最好用的终端工具，听说没有之一。配合oh-my-zsh,你的终端居然可以这样！震惊！！（UC震惊部） 池建强大大有一篇文章《终极 Shell》讲mac下的终端，讲的比较好，贴这。大家可以做取舍。 - Cmder 如果你用过Windows自带的cmd，简直想shi有没有！页面丑就算了！没有tab！窗口不能缩放！不能用鼠标复制文本！！@#￥%&amp;*￥%…%￥ Cmder绝对是一款Windows环境下的cmd替代者，支持了大部分的Linux命令。 支持tab标签 集成git 支持绝大Unix/Linux命令 但是安装之后一般都会有以下几个问题： 中文乱码问题 文字重叠问题 λ其实可以替换成$ 2. Homebrew VS Chocolatey 包管理工具 - Homebrew为什么要用Homebrew？官网讲得很露骨，一款macOS缺失的软件包管理器 安装Homebrew：命令行输入1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 举个栗子，如果你要安装sublimeText，你可以这样：1brew install sublime-text 再优雅点，你可以安装Homebrew的命令行工具homebrew-cask12345brew tap phinze/homebrew-cask &amp;&amp; brew install brew-cask然后你可以这样愉快地安装一堆软件brew cask install sublime-text skitch dropbox google-chrome 用Homebrew安装软件有什么好处么？ 将软件包安装到独立目录，并将其文件软链接至 /usr/local 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置 完全基于git和ruby，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并 - ChocolateyChocolatey官网是这么介绍自己的，The package manager for Windows. 安装嘿嘿，这个时候打开上面提到的cmder命令行工具，输入: 1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot; 这个时候如果你也要装sublimeText3，你也可以这样！1choco install SublimeText3 是不是很酷！好处同上，具体的配置自行琢磨，这个时候已经和Mac下的体验很接近了。让我们再近一步！~ 3. Spotlight VS Listary 文件浏览增强工具 - Spotlight自从升级到macOS Sierra后，其实mac自带的Spotlight已经很强大了，至于类似Alfred的神器，我倒觉得一般用户没必要折腾了，当然你想更Geek点，可以折腾下Alfred，毕竟那样看起来很酷！ 安利VueJs时刻！ - Listary Listary的出现，让突然从Mac转向Windows开发的我产生的强烈排斥心理得到了一定的缓解！ 先说说效果经过我的配置，我想要打开某一软件或者文件，双击Ctrl，弹出Listary小窗，输入几个模糊关键字，回车！仿佛置身于Mac有没有！！ 下载安装官网有free版和Pro版，至于破解还是支持正版… 界面举栗 如果你是Mac用户，我想是无缝衔接的，配置快捷键后，效率也是极高的！ 4. Clover 给Windows资源管理器加上Tab标签 不知道Windows用户有没有注意到，每次打开我的电脑，会弹出一个新的窗口，再打开，再弹！再打开！再弹！循环个几次，桌面上会有一堆“我的电脑”窗口，是的，一堆……一堆……堆…… 所以你需要一个类似chrome标签一样的工具，帮你窗口整合。这就是[Clover]唯一的作用。 Clover下载地址 同样的，你可以将常用的地址存为标签，类似浏览器收藏夹，方便下次打开。 继续寻觅中……对我来说，应该是对于绝大部分开发者来说，开发环境的舒适是很重要的，想方设法提高效率，我倒觉得折腾这些工具也是挺有必要的。 应该会持续更新吧，毕竟Windows下坑还很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git工作流之一(集中式工作流)]]></title>
      <url>%2FGit%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%B9%8B%E4%B8%80--%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%2F</url>
      <content type="text"><![CDATA[引言一言不合讲个小故事 一个和尚有水喝，两个和尚挑水喝，三个和尚没水喝。 故事暴露了团队协作的问题，但接下来的故事与和尚无关，只是讲讲团队协作的事儿。 贯穿全文的角色 老A：技术Leader 阿B：工程师 小C：实习生 Git工作流 Git是Linux老爹的强大发明之一，用C语言编写。强大的工具也因使用情景、使用对象的不同，衍生出不同的Git工作流。 情景一：集中式工作流 情景二：功能分支工作流 情景三：Gitflow工作流 情景四：Forking工作流 情景一：集中式工作流1. 老A初始化工程 老A在服务器上新建了一个repository（下文均以本人的github/git-workflow-story为例子） 12345mkdir git-workflow-story &amp;&amp; cd &quot;$_&quot;// 当然你也可以在bash里自定义 mkdir&amp;cd 等快捷命令git initgit remote add origin https://github.com/palmerye/git-workflow-story.git 2. 阿B开始写故事 阿B的任务是在repo里写Readme(Markdown) 12345mkdir story-B &amp;&amp; cd &quot;$_&quot;git clone https://github.com/palmerye/git-workflow-story.gitvi readme.md 于是阿B在readme里面写了一点东西，打算push到老A建的repo里。123456git add readme.mdgit commit -m &quot;这是阿B的第一次提交&quot;git push -u origin master// -u 参数用来初次push的时候指定默认upstream上游分支 3. 小C来啦 有一天，老A觉得阿B一个人忙不过来，找来小C来帮忙 上班第一天，小C就开始忙活，也打算在老A的repo里写点东西。 123mkdir story-C &amp;&amp; cd &quot;$_&quot;git clone https://github.com/palmerye/git-workflow-story.git 这个时候repo里已经有了阿B的第一次push的文件，小C突然发现有个错别字，就顺便改了。 12345git add readme.mdgit commit -m &quot;修改了一个错别字&quot;git push -u origin master 4. 冲突阿B下午又写了点东西，和之前一样，暂存/提交/推送，突然git push失败了（错误提示本地仓库落后于远端）。于是机智的阿B有了如下操作： 1git pull --rebase origin master 再次push的时候发现有冲突，于是去解决冲突。发现和小C改了同一个地方，于是自己修改完继续push。 git merge的冲突判定机制如下：先寻找两个commit的公共祖先，比较同一个文件分别在ours和theirs下对于公共祖先的差异，然后合并这两组差异。如果双方同时修改了一处地方且修改内容不同，就判定为合并冲突，依次输出双方修改的内容。 12345git add . git rebase --continuegit push origin master 故事完结 从此他们在一起过上了幸福的Coder生活。 由上面的故事我们可以看到，集中式工作流只有一条master分支，而且维护得干净一点，永远只有一条分支。多人协作的时候，推送前要确保自己本地状态和远端保持同步，因此要记得rebase。但局限就是，一条分支很难去管理多个开发状态，因此在集中式工作流的基础上，有了后文的功能分支工作流。 补充点东西 git pull 时，–rebase参数可以让分支更整洁 git pull前123 B1---B2 master /A---B---C origin/master 不加–rebase/相当于merge123 B1---B2 master / \A---B--------C origin/master 加上–rebase，告别合并点，让分支更整洁1A---B---C---B1---B2 master, origin/master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[扫盲笔记--H5视频直播]]></title>
      <url>%2F%E6%89%AB%E7%9B%B2%E7%AC%94%E8%AE%B0-H5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%2F</url>
      <content type="text"><![CDATA[项目需要，这里做一个简单的笔记梳理 视频直播流程：采集端 ==&gt; 服务器端 ==&gt; 播放端 流程图用的一个Chrome插件，Gliffy Diagrams。 先把这些协议讲一讲1. RTMP（Real Time Messaging Protocol） RTMP是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。 工作原理：在RTMP协议中的基本数据单元称为Message（消息），在传输数据的过程中，Message会被拆分成更小快的Chunk（消息块）。 传输媒体流的过程：1.发送端将媒体数据封装成Message 2.再把Message切分成Chunk 3.基于TCP协议发送 4.接收端通过TCP收到Chunk 5.将Chunk重组成Message 6.对Message解包得到媒体数据 特点 延迟低 RTMP协议基于TCP底层通讯协议，属于长链接，收到数据后立即发送 延迟累积 还是因为基于TCP，丢包少（TCP重传机制）,网络差的时候服务器将包缓存，等到网络好的时候在一并发给服务器。 隐私性理想 2. HLS（HTTP Live Streaming） 关键词：切片。 HLS协议规定: 视频的封装格式是TS。 视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。 定义了用来存放流配置和路径的m3u8索引文件。 先来show一段基于HLS协议的视频播放code 1234567...&lt;div id=&quot;player&quot;&gt; &lt;video width=&quot;640&quot; height=&quot;320&quot; controls&gt; &lt;source src=&quot;http://..url../live/livestream.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt;&lt;/div&gt;... 如果要兼容所有浏览器，需要接第三方播放器，比如video.js 工作原理：把整个流切分成一个个基于HTTP的小文件（ts文件），用m3u8索引表来管理这些小切片。可以看到上面👆这段code中的source，是一个.m3u8文件，所以当视频播放的时候，video标签解析这个索引文件（动态更新），然后按序去找到对应的ts文件（真正存放视频数据的文件）并连续播放。 特点： 跨平台（ios、Android、pc） RTMP基于flash，ios不支持 基于HTTP，容易接CDN 实时性差（延迟一般在10s-30s左右） 由于流被切片下载，假设.m3u8索引列表里有n个ts文件，每个ts文件包含m秒视频内容，同时推流端又有新的流推上来，但拉流端才刚刚看到下载下来的切片流，所以延迟就是n*m秒。想要延迟小，理想就让n和m的值最小到1，几乎零延迟，由于HLS基于HTTP协议，所以随之而来的就是请求次数增加，server端压力大。因此要平衡取舍。 PS：苹果官方推荐的ts时长为10s，列表3个ts文件，因此会有大概30s的延迟。https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html 3.What duration should media files be? The main point to consider is that shorter segments result in more frequent refreshes of the index file, which might create unnecessary network overhead for the client. Longer segments will extend the inherent latency of the broadcast and initial startup time. A duration of 10 seconds of media per file seems to strike a reasonable balance for most broadcast content. 4.How many files should be listed in the index file during a continuous, ongoing session? The normal recommendation is 3, but the optimum number may be larger… 3. WebRTC（Web Real-Time Communication） 是一个支持网页浏览器进行实时语音对话或视频对话的 API。它于 2011 年 6 月 1 日开源并在 Google、Mozilla、Opera 支持下被纳入万维网联盟的 W3C 推荐标准。 浏览器兼容性 可以看到，截止目前（2017.2.14），WebRTC的兼容性还是惨不忍睹，只在PC端的Chrome比较好（毕竟是谷歌2010年以6820万美元收购Global IP Solutions公司而获得的一项技术）。不过风头火热，xxxx，指日可待。 工作原理简单的一句话就是，让浏览器提供JS的即时通信API。通过一系列的信令建立浏览器之间的信道，来传输音频视频数据。与WebSocket的区别就是，少了中间的WebSocket服务器。 其实没那么simple先来看看用WebRTC实现一场会议直播的正常流程 其实p2p（peer to peer）就能跑起来了 推流端（如Chrome浏览器）调用相关的媒体API来获取音视频源 中转的MCU服务器（不是说不需要么？因为chrome给超过10个用户推流的时候很容易崩），对音视频做一些简单的处理。 客户端（如Chrome）连接MCU，并获取媒体流。 之前在项目里用过声网的WebRTC的SDK，所以感觉这项技术还是牛honghong的。 4. HTTP-FLV （补充） 顾名思义，就是将音视频数据流封装成FLV，再通过HTTP协议传输给客户端。 特点 延时低（与RTMP媲美） 穿透性强（基于HTTP80端口通信） 可以使用HTTPS做加密通道 上面讲得差不多了，这里就做个小总结。 采集端(推流端)如开头的流程图中所述，一般常用的就是RTMP推流，因为延迟较小。 补充：几个主流的 web直播平台，几乎都是以HTTP-FLV为直播协议。 推荐一个推流工具：OBS Server端简单的说就是一台流媒体服务器，用来接收流和分发流。 e.g. 比如一台Nginx服务器，要扩展支持RTMP，用的较多是这个： https://github.com/arut/nginx-rtmp-module 播放端(拉流端) FlashPlayer浏览器支持（RTMP） h5的video标签（HLS） 火爆的flv.js（那个B站工资5000的大神，可惜走了）（HTTP-FLV） 实现了H5端对FLV格式的播放，终于解脱了臃肿的Flash。 说了这么多，大厂都有了视频直播的解决方案，直接拿来用也挺省心。 参考文章： http://www.cnblogs.com/luconsole/p/6079534.html https://www.nihaoshijie.com.cn/index.php/archives/615 这篇笔记做下来，真的是觉得视频这块领域很大呢，要想更深入还是需要花大力气学习的。肯定有很多不妥当的地方，希望多批评，文章也会持续更新…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web + Log = Blog]]></title>
      <url>%2FWeb-Log-Blog%2F</url>
      <content type="text"><![CDATA[Blog原来是这样来的 博客（英语：Blog，为Web Log的混成词），意指log on the web意即在网络上纪录，是一种由个人管理、张贴新的文章、图片或视频的网站或在线日记，用来纪录、抒发情感或分享信息。 From Wiki. 我为什么要写博客For 生存 自从看了阮一峰老师的Blog，我才知道什么叫全能；频繁的浏览他的Blog，我才意识到全能的背后是文章的高产。 *知识梳理，才知道自己哪里缺胳膊少腿 给别人一个爱批评你的机会 一不小心能帮到同行呢 信息整合，也许有一天，不需要再这里Google那里Baidu了，Local Search就能找到信息 扩大在圈子里的影响力 （打这几个字我都有点手抖） For 生活 有没有发现，年级大了，QQ空间没什么动态更新了，朋友圈发得少了，不易悲，也不易喜。 写一些经历和想法，也许能和visitors产生一些共鸣 用文字和图片记录下一些生活，常常翻翻，听说这样不会抑郁 我挺喜欢拍照，拿blog当个web相册也不错 关于这个博客一些东西 暂时搭建在github良心的Pages上（Repository） 如果你手滑点进去了，那就手滑star下吧 搭建于gh-pages分支。为什么不用palmerye.github.io?另有他用，其实没多大区别 Blog工具用的Hexo，主题是Next，自己稍做了一点修改 首页的封面图是用AI画的矢量图，从PCB到Code，也表示自己从硬件转型到软件的历程，每一段经历都很宝贵，值得珍惜。 该加的功能都加了，包括站点底下的PV和UV统计 或许上面👆这条是假的，我们的工作就是不断否定自己 日子如何，力量也如何。这句话出于《圣经·申命记》33:25 关于博客的目的，说到底还是一句话，利人利己 因为我觉得这样很酷。]]></content>
    </entry>

    
  
  
</search>
